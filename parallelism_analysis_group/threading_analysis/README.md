# スレッディング分析
スレッディング分析を使用すると、アプリケーションが利用可能なプロセッサの計算コアをどれだけ効率的に使用しているかを特定し、スレッディングランタイムの使用における非効率性や、スレッディング同期の競合に関する問題点を探ることができます。  
これらの競合は、スレッドを待機状態にして効果的なプロセッサ活用を妨げる原因となります

ntel® VTune™ Profilerは、「Effective CPU Utilization（効果的なCPU使用率）」という指標をスレッディング効率の主な測定基準として使用します。  
この指標は、アプリケーションが利用可能な論理コアをどのように活用しているかを基に構築されています。スループットコンピューティングでは、通常、1つの物理コアにつき1つの論理コアを負荷するのが一般的です。  
スレッディング分析における以下の観点は、CPU使用率が低い理由を示唆する可能性があります：  
- **スレッド数**: アプリケーションのスレッド数をざっと確認することで、スレッディングの非効率性（固定されたスレッド数が原因で、より多くのコアへのスケーリングが制限されたり、スレッドの過剰割り当てが発生したりする）に関する手掛かりを得ることができます。
- **待機時間**（トレースベースまたはコンテキストスイッチベース）: 同期オブジェクトやI/O待ちによるスレッドの待機時間を分析します。
- **スピン待機とオーバーヘッド時間**: スレッディングランタイムのオーバーヘッドやスピンウェイト（ビジーウェイトやアクティブウェイト）の影響を見積もります
  image
-** ユーザーモードサンプリングとトレーシング**: 同期オブジェクトを認識し、トレーシングを使用してオブジェクトごとのスレッド待機時間を収集できます。これはスレッド間の相互作用セマンティクスを理解し、そのデータに基づいて最適化を行うのに役立ちます。Intel VTune Profiler では、2つの同期オブジェクトグループをサポートしています。一つはスレッド間の同期に通常使用されるオブジェクト（例: ミューテックスやセマフォ）、もう一つはI/O操作の待機に関連するオブジェクト（例: ストリーム）です
- **ハードウェアイベントベースのサンプリングとコンテキストスイッチ**: コンテキストスイッチ情報に基づいてスレッドの非アクティブな待機時間を収集します。この場合、スレッドオブジェクトの定義はありませんが、コールスタックに基づく待機時間を使用することで問題のある同期関数を特定できます。この方法は前の収集モードよりもオーバーヘッドが少なくて済みます。また、コンテキストスイッチに基づく分析ではスレッドのプリエンプション時間も示され、これはスレッド過剰割り当てがシステムに与える影響を測定するのに有用です。

## ユーザーモードサンプリングとトレーシングの仕組み
VTune ProfilerがスレッディングおよびブロッキングAPIをインストルメント化し、実行時に呼び出しをインターセプトしてスレッド相互作用フローを構築し、同期オブジェクトを検出します。
ユーザーモードサンプリングとトレーシング収集分析モードを使用すると、各同期オブジェクトがアプリケーションに与える影響を評価し、アプリケーションが各同期オブジェクトやブロッキングAPIでどの程度の待機時間を要したかを理解できます。
分析では、タイムラインビュー上でスレッドの実行フローが一つのスレッドから別のスレッドに移行し、同期オブジェクトを解放および取得する様子が表示されます。
このモードがアプリケーション実行時に大きなオーバーヘッドを引き起こす場合、待機時間収集をより控えめに行う方法として、ハードウェアイベントベースのサンプリングとコンテキストスイッチモードを試してください。

image

## ハードウェアイベントベースのサンプリングとコンテキストスイッチの仕組み
マルチタスクオペレーティングシステムでは、すべてのソフトウェアスレッドが一定の時間スライス（スレッド実行クォンタム）内で実行されます。ハードウェアイベントベースのサンプリングとコンテキストスイッチモードでは、スレッドがプロセッサ上でスケジュールされて開始および終了する際（つまりスレッドクォンタムの境界で）、プロファイラーが制御を獲得します。
このモードでは、スレッドが非アクティブ化される理由も特定します。理由には、同期の明示的な要求やスレッドクォンタムの終了（オペレーティングシステムのスケジューラーが現在のスレッドをプリエンプトしてより高優先度のスレッドを実行する場合）などがあります。
スレッドが非アクティブである間の時間は測定され、「非アクティブ待機時間（Inactive Wait Time）」と呼ばれます。非アクティブ待機時間は非アクティブの理由に基づいて区別されます：
- **非アクティブ同期待機時間**（Inactive Sync Wait Time）：同期の要求によって発生します。
- **プリエンプション待機時間**（Preemption Wait Time）：プリエンプトによって発生します

コンテキストスイッチ情報がコールスタックと共に収集されるため、待機関数とその呼び出し経路を通じて非アクティブ待機時間の原因を探ることが可能です。ハードウェアイベントベースのサンプリングとコンテキストスイッチモードでは、同期オブジェクトやI/O操作によって待機が発生したコード上の箇所を表示します。  
このモードは、ハードウェアイベントベースのサンプリング収集に基づいており、システム上で稼働中のすべてのプロセスを分析し、コンテキストスイッチデータを提供することでシステム全体のパフォーマンスを評価します。Linuxシステムでは、ドライバ不要のPerfベースの収集を使用した非アクティブ待機時間収集がカーネルバージョン4.4以降で利用可能です。また、非アクティブ時間の原因はカーネルバージョン4.17以降で利用可能です。
