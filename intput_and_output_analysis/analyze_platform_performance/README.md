# Analyze Platform Performance
入力および出力分析は、プラットフォームレベルの指標を提供するよう設計されている
- 外部PCIeデバイスまたは統合アクセラレータであるかに関係なく、I/Oデバイス単位でプラットフォームI/Oトラフィックを分析
- Intel® Data Direct I/O技術（Intel® DDIO）の利用効率を分析
- Intel® Virtualization Technology for Directed I/O（Intel® VT-d）の利用状況を分析
- DRAMおよび永続メモリの帯域幅消費を監視
- 非効率的なリモートソケットアクセスによって引き起こされる可能性があるI/O性能の問題を特定
- 出力I/O（MMIO）トラフィックの発生元を特定


## GUI

### Platform Diagram 
入出力分析は、I/OデバイスおよびIntel® UPIリンク、DRAM、永続メモリ、物理コアのシステムトポロジーと使用率の指標を示します

**使い方**
```
ONEAPI_DEVICE_SELECTOR=opencl:cpu vtune --collect io -knob mmio=true -- ./a.out
```
N/A on non-Xeon CPU.

I/Oデバイスは、PCIeバスとデバイス番号を示す短い名前で表示されます。デバイスのツールチップには、完全なデバイス名、リンクの性能、およびステータスが表示されます。デバイスの画像にカーソルを合わせることで、詳細なデバイス情報を確認できます

プラットフォーム図は、スループットが制限される原因となる可能性のあるデバイスステータスの問題を強調表示します。一般的な問題として、設定されたリンク速度/幅がデバイスの最大速度/幅と一致しないことがあります

- デバイスの性能が判明しており、最大の物理帯域幅が計算可能な場合、デバイスリンクには、データ転送に使用された帯域幅と利用可能な物理帯域幅の比率を表す「有効リンク利用率」メトリックが割り当てられます。このメトリックはプロトコルオーバーヘッド（TLPヘッダー、DLLP、物理エンコーディング）を考慮せず、ペイロードに基づいたリンク利用率を反映します。そのため、100％に達することはありません。ただし、このメトリックは、リンクが飽和状態からどの程度離れているかを判断する手がかりを提供します。理論上の最大帯域幅は、デバイスツールチップに示されているデバイスリンクの性能に基づいて計算されます
- プラットフォーム図では、分析設定で「最大DRAM帯域幅を評価する」チェックボックスが選択されている場合、「平均DRAM利用率」を表示します。それ以外の場合は、「平均DRAM帯域幅」を表示します
- システムに永続メモリが搭載されている場合、プラットフォーム図には「平均永続メモリ帯域幅」が表示されます。
- 「平均UPI利用率」メトリックは、送信に基づくUPIの使用状況を示します。プラットフォーム図では、クロスソケット接続が1つしか表示されず、パッケージペアを接続するUPIリンクの数に関係なく、最大値が表示されます
- 各ソケットの上部に表示される「平均物理コア利用率」メトリックは、分析対象のアプリケーションの計算による物理コアの使用率を示します。

### プラットフォームI/O帯域幅を分析
プラットフォーム上のI/Oトラフィック処理を調査するには、Summaryウィンドウの「PCIeトラフィック概要」セクションから調査を開始します。これらのトップレベルのメトリックは、総受信および送信I/Oトラフィックを反映しています：
- 受信PCIe帯域幅は、外部PCIeデバイスや統合アクセラレータなどのI/Oデバイスによって引き起こされ、システムメモリへの読み取りおよび書き込みが行われます。これらの読み取りおよび書き込みは、Intel® Data Direct I/O（Intel® DDIO）機能を通じてプラットフォームによって処理されます。
- 受信PCIeリード — I/Oデバイスがプラットフォームメモリからデータを読み取ります。
- 受信PCIeライト — I/Oデバイスがプラットフォームメモリにデータを書き込みます。
- 送信PCIe帯域幅は、I/Oデバイスのメモリまたはレジスタをターゲットとするコアトランザクションによって引き起こされます。通常、コアはMemory-Mapped I/O（MMIO）アドレス空間を通じてデバイスメモリにアクセスします。
- 送信PCIeリード — コアがデバイスのレジスタからデータを読み取ります。
- 送信PCIeライト — コアがデバイスのレジスタにデータを書き込みます

受信および送信PCIe帯域幅メトリックの粒度は、CPUモデル、使用されるコレクター、およびユーザーの権限に依存します。
"Platform"タブのタイムラインを使用して、デバイス単位で時間経過に伴う受信および送信PCIe帯域幅を分析できます。

N/A on non-Xeon CPU.

### DPDKアプリケーションを分析
**使い方**
```
ONEAPI_DEVICE_SELECTOR=opencl:cpu vtune --collect io -knob dpdk=true -- ./a.out
```

N/A on non-Xeon CPU.

### SPDKアプリケーションを分析
**使い方**
```
ONEAPI_DEVICE_SELECTOR=opencl:cpu vtune --collect io -knob spdk=true -- ./a.out
```

N/A on non-Xeon CPU.

### LinuxカーネルI/Oを分析
ハードウェアイベントに基づくサンプリング収集とシステム全体のFtrace*収集を使用して、ハードウェアイベントと組み合わされたストレージシステムの一貫したビューを提供します。

カーネルI/O分析のための以下のシステム全体のメトリックを提供します
- I/O待機 — このシステム全体のメトリックは、スレッドがI/O待機状態にあるためにCPUコアがアイドル状態になっていた時間を表します
- I/Oキュー深度 — このメトリックは、ストレージデバイスに送信されたI/Oリクエストの数を示します。キュー内のリクエスト数がゼロの場合、それはスケジュールされたリクエストがなく、ディスクが全く使用されていないことを意味します
- I/Oデータ転送 — このメトリックは、ストレージデバイスから読み取られたまたは書き込まれたバイト数を示します
- ページフォルト — このメトリックは、システム上で発生したページフォルトの数を示します。特にメモリマップファイルへのアクセスを分析する際に有用です
- CPUアクティビティ — このメトリックは、システムが以下のいずれかの状態に費やした時間の割合を表します
  - アイドル状態 — CPUコアがアイドル状態
  - アクティブ状態 — CPUコアがスレッドを実行している状態
  - I/O待機 — CPUコアがアイドル状態だが、ディスクアクセスによってブロックされているスレッドがこのコア上で実行可能である状態
 VTune Profilerによって収集されるI/O待機時間、I/O待機数、およびI/Oキュー深度などのすべてのI/Oメトリックは、システム全体モードで収集され、ターゲット固有ではありません

**使い方**
```
ONEAPI_DEVICE_SELECTOR=opencl:cpu vtune --collect io -knob kernel-stack=true -- ./a.out
```
**Analyze I/O Wait Time**
I/O待機時間メトリックは、スレッドがI/O待機状態にある間にシステムがコアをアイドル状態で保持している時間の一部を表します。この場合、スレッド数はアイドル状態のコア数を超えません。この集計されたI/O待機時間メトリックは、「Bottom-up」ウィンドウのタイムラインペインで利用可能なI/O待機メトリックの積分関数です。
![image](https://github.com/user-attachments/assets/75307558-48e8-4d14-ae9a-89ac2bbf3d5a)

カーネルサブシステムによるストレージリクエストの処理速度を推定するには、**Disk Input and Output Histogram（ディスク入力および出力ヒストグラム）**を参照してください。Operation Typeドロップダウンメニューを使用して、関心のあるI/O操作の種類を選択します。例えば、I/Oライトの場合、0.06秒以上かけて実行された2〜4件のストレージリクエストは、VTune Profilerによって「遅い」と分類されます。

![image](https://github.com/user-attachments/assets/dff0e7c5-aec8-40a5-bdaf-a89ff00a375f)
N/A on non-Xeon CPU

**Analyze Slow I/O Requests**
タイムラインで関心のある領域を選択し、コンテキストメニューの「ズームイン」と「選択によるフィルター」オプションを使用します。Summaryヒストグラムが更新され、選択した時間範囲のデータが表示されます
![Screenshot 2025-03-23 195814](https://github.com/user-attachments/assets/93ab6981-e649-4759-b232-d043357c0d76)

関心のある領域をズームインすることで、さまざまなメトリックを詳細に確認し、高いI/O待機時間の原因を理解することができます

VTune Profilerは、スレッドによるI/Oアクセスが原因で発生するI/O待機タイプのコンテキストスイッチを収集し、CPUアクティビティ領域でシステム全体のI/O待機メトリックを提供します。このデータを使用して、I/O操作と計算操作の不均衡を特定します。

システム全体のI/O待機は、システムコアがアイドル状態である時間を示しますが、その間にI/Oアクセスによるコンテキストスイッチが行われているスレッドがあります。このメトリックを使用して、ストレージ媒体への依存度を推定します

例えば、I/O待機値が100%の場合、システムのすべてのコアがアイドル状態であり、I/Oリクエストによってブロックされているスレッドが存在します。この問題を解決するには、計算スレッドをI/Oタスクと並行して実行するようにアプリケーションのロジックを変更するか、より高速なストレージを使用することを検討してください

一方、I/O待機値が0%の場合、次のいずれかを意味する可能性があります
- ストレージアクセスでブロックされているスレッド数に関係なく、すべてのCPUコアがアプリケーションコードを積極的に実行している
- ストレージアクセスでブロックされているスレッドが存在しない。

I/Oキュー深度領域を探索することで、ストレージデバイスに送信されたストレージリクエストの数を確認できます。スパイクは最大リクエスト数に対応します。I/Oキュー深度チャート上のゼロ値ギャップは、ストレージが全く使用されていなかったアプリケーションの実行ポイントに対応します

遅いI/Oパケットが実行のためにスケジュールされた正確な時点を特定するには、I/Oキュー深度メトリックに「遅い」マーカーを有効にしてください。

高帯域幅のポイントを特定するには、ストレージデバイスから読み取られたまたは書き込まれたバイト数を示すI/Oデータ転送領域を分析してください

### I/O関数のコールスタックを分析
すべてのユーザースペースI/O関数を計測します。これにより、計測されたユーザースペースのアクティビティと遅いI/Oリクエストを関連付けることができます。この関連付けは、正確なAPI呼び出しを指す完全なコールスタックを調査することで可能です

![image](https://github.com/user-attachments/assets/5688614d-0fab-4396-89fc-2803b2773506)




