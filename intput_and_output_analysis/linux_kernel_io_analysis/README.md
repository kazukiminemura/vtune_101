# LinuxカーネルI/Oを分析
ハードウェアイベントに基づくサンプリング収集とシステム全体のFtrace*収集を使用して、ハードウェアイベントと組み合わされたストレージシステムの一貫したビューを提供します。

カーネルI/O分析のための以下のシステム全体のメトリックを提供します
- I/O待機 — このシステム全体のメトリックは、スレッドがI/O待機状態にあるためにCPUコアがアイドル状態になっていた時間を表します
- I/Oキュー深度 — このメトリックは、ストレージデバイスに送信されたI/Oリクエストの数を示します。キュー内のリクエスト数がゼロの場合、それはスケジュールされたリクエストがなく、ディスクが全く使用されていないことを意味します
- I/Oデータ転送 — このメトリックは、ストレージデバイスから読み取られたまたは書き込まれたバイト数を示します
- ページフォルト — このメトリックは、システム上で発生したページフォルトの数を示します。特にメモリマップファイルへのアクセスを分析する際に有用です
- CPUアクティビティ — このメトリックは、システムが以下のいずれかの状態に費やした時間の割合を表します
  - アイドル状態 — CPUコアがアイドル状態
  - アクティブ状態 — CPUコアがスレッドを実行している状態
  - I/O待機 — CPUコアがアイドル状態だが、ディスクアクセスによってブロックされているスレッドがこのコア上で実行可能である状態
 VTune Profilerによって収集されるI/O待機時間、I/O待機数、およびI/Oキュー深度などのすべてのI/Oメトリックは、システム全体モードで収集され、ターゲット固有ではありません

**使い方**
```
ONEAPI_DEVICE_SELECTOR=opencl:cpu vtune --collect io -knob kernel-stack=true -- ./a.out
```
## Analyze I/O Wait Time
I/O待機時間メトリックは、スレッドがI/O待機状態にある間にシステムがコアをアイドル状態で保持している時間の一部を表します。この場合、スレッド数はアイドル状態のコア数を超えません。この集計されたI/O待機時間メトリックは、「Bottom-up」ウィンドウのタイムラインペインで利用可能なI/O待機メトリックの積分関数です。
![image](https://github.com/user-attachments/assets/75307558-48e8-4d14-ae9a-89ac2bbf3d5a)

カーネルサブシステムによるストレージリクエストの処理速度を推定するには、**Disk Input and Output Histogram（ディスク入力および出力ヒストグラム）**を参照してください。Operation Typeドロップダウンメニューを使用して、関心のあるI/O操作の種類を選択します。例えば、I/Oライトの場合、0.06秒以上かけて実行された2〜4件のストレージリクエストは、VTune Profilerによって「遅い」と分類されます。

![image](https://github.com/user-attachments/assets/dff0e7c5-aec8-40a5-bdaf-a89ff00a375f)
N/A on non-Xeon CPU

## Analyze Slow I/O Requests
タイムラインで関心のある領域を選択し、コンテキストメニューの「ズームイン」と「選択によるフィルター」オプションを使用します。Summaryヒストグラムが更新され、選択した時間範囲のデータが表示されます
![Screenshot 2025-03-23 195814](https://github.com/user-attachments/assets/93ab6981-e649-4759-b232-d043357c0d76)

関心のある領域をズームインすることで、さまざまなメトリックを詳細に確認し、高いI/O待機時間の原因を理解することができます

VTune Profilerは、スレッドによるI/Oアクセスが原因で発生するI/O待機タイプのコンテキストスイッチを収集し、CPUアクティビティ領域でシステム全体のI/O待機メトリックを提供します。このデータを使用して、I/O操作と計算操作の不均衡を特定します。

システム全体のI/O待機は、システムコアがアイドル状態である時間を示しますが、その間にI/Oアクセスによるコンテキストスイッチが行われているスレッドがあります。このメトリックを使用して、ストレージ媒体への依存度を推定します

例えば、I/O待機値が100%の場合、システムのすべてのコアがアイドル状態であり、I/Oリクエストによってブロックされているスレッドが存在します。この問題を解決するには、計算スレッドをI/Oタスクと並行して実行するようにアプリケーションのロジックを変更するか、より高速なストレージを使用することを検討してください

一方、I/O待機値が0%の場合、次のいずれかを意味する可能性があります
- ストレージアクセスでブロックされているスレッド数に関係なく、すべてのCPUコアがアプリケーションコードを積極的に実行している
- ストレージアクセスでブロックされているスレッドが存在しない。

I/Oキュー深度領域を探索することで、ストレージデバイスに送信されたストレージリクエストの数を確認できます。スパイクは最大リクエスト数に対応します。I/Oキュー深度チャート上のゼロ値ギャップは、ストレージが全く使用されていなかったアプリケーションの実行ポイントに対応します

遅いI/Oパケットが実行のためにスケジュールされた正確な時点を特定するには、I/Oキュー深度メトリックに「遅い」マーカーを有効にしてください。

高帯域幅のポイントを特定するには、ストレージデバイスから読み取られたまたは書き込まれたバイト数を示すI/Oデータ転送領域を分析してください

## I/O関数のコールスタックを分析
すべてのユーザースペースI/O関数を計測します。これにより、計測されたユーザースペースのアクティビティと遅いI/Oリクエストを関連付けることができます。この関連付けは、正確なAPI呼び出しを指す完全なコールスタックを調査することで可能です

![image](https://github.com/user-attachments/assets/5688614d-0fab-4396-89fc-2803b2773506)
